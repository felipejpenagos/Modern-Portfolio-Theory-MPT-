# portfolio_optimization_simulation

'''
Portfolio Optimization Summary

This code performs portfolio optimization using two methods: Monte Carlo simulation and mathematical optimization with scipy.optimize.minimize.

Data Preparation
Historical adjusted close prices for four stocks (AMD, AAPL, MSFT, ORCL) are loaded, and daily returns are computed.

Monte Carlo Simulation
10,000 random portfolios are generated by assigning random weights to each stock. Weights are normalized so they sum to 1, representing full investment. For each portfolio, expected annual return, volatility (using the annualized covariance matrix), and Sharpe ratio are calculated. The portfolio with the highest Sharpe ratio is identified.

Scipy Optimization (SLSQP Method)
Instead of sampling random portfolios, this approach uses the Sequential Least Squares Programming (SLSQP) algorithm to directly find the optimal weights that maximize the Sharpe ratio. Since minimize() can only minimize functions, the Sharpe ratio is negated.
A constraint is passed to the optimizer to ensure that the weights sum to 1. This is expressed using a lambda function lambda x: np.sum(x) - 1, which evaluates to zero only when the sum equals one. Bounds are also applied to keep weights between 0 and 1, preventing shorting.

Result Comparison and Visualization
Both the Monte Carlo and optimized portfolios are plotted on the efficient frontier, allowing visual comparison of their risk-return profiles. The portfolio weights and Sharpe ratios for each approach are printed.
'''
